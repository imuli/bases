{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE OverloadedStrings #-}

-- |
-- Module       : Data.Encoding.Base41
-- License      : Unlicense (Public Domain dedication)
--
-- Maintainer   : Imuli <i@imu.li>
-- Stability    : Experimental
-- Portability  : portable
--
-- Base41 encodings.
--

module Data.Encoding.Base41
  ( base41alphas
  , base41sveljko
  , decode41Lenient
  , decode41Strict
  , encode41
  -- for making your own base41 encoding
  , make41decoderLenient
  , make41decoderStrict
  , make41decodeTable
  , make41encoder
  , make41encodeTable
  ) where

import Data.Encoding.Fixed
import Data.Encoding.Endian

import Data.Bits (shiftL, shiftR, (.|.))
import Data.Word (Word32, Word16, Word8)
import Data.ByteString (ByteString, index, elemIndex)
import Data.Vector.Unboxed (Vector, generate, unsafeIndex)

import Foreign.Ptr (Ptr, plusPtr)
import Foreign.Storable (peek, poke)

-- | The default alphabet, created with these goals in mind:
--
-- - Sorting: Encoding data should preserve byte-wise sorting order.
-- - Characters: Encoded data should be valid indentifiers in common programming languages.
-- - Embedding: Should be fast and constant time encode even on embedded systems without lookup table.
-- 
-- Encoding from 0..41 -> [0x41..0x4f,0x61..0x7a]:
-- > a = x + 0x41 + ((x .|. x `shiftR` 1) .&. 0x10)
--
-- Decoding from [0x41..0x4f,0x61..0x7a] -> 0..41:
-- > t = a - 0x41
-- > x = t - ((t .|. t `shiftL` 1) .&. 0x20) + (t `shiftR` 1 .&. 0x10)
--
-- Though if you don't mind taking 'O'..'`' as valid inputs decode simplifies to:
-- > t = a - 0x41
-- > x = t - (t `shiftR` 1 .&. 0x10)

base41alphas :: ByteString
base41alphas = "ABCDEFGHIJKLMNOPabcdefghijklmnopqrstuvwxy"

-- | The alphabet proposed by Srdjan Veljkovic, at <https://github.com/sveljko/base41/blob/master/base41.md>.

base41sveljko :: ByteString
base41sveljko = ")*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQ"

type Base41EncodeTable = Vector Word32

-- | Make an encoding table from an alphabet.

make41encodeTable :: ByteString -> Vector Word32
make41encodeTable alphabet = generate 65536 $ \n ->
  let i = fromIntegral $ asBE @Word16 $ fromIntegral n
      (z', z) = i `divMod` 41
      (x, y) = z' `divMod` 41
      a = fromIntegral $ index alphabet x
      b = fromIntegral $ index alphabet y
      c = fromIntegral $ index alphabet z
   in asBE $ a `shiftL` 24 .|. b `shiftL` 16 .|. c `shiftL` 8

-- | The base41 encoding inner loop.

enc41 :: Base41EncodeTable -> Ptr Word16 -> Ptr Word32 -> IO ()
enc41 !table !src !dst = do
  x <- peek src
  poke dst (table `unsafeIndex` fromIntegral x)

-- | The base41 encoding finalizer.

fin41enc :: Base41EncodeTable -> Int -> Ptr Word8 -> Ptr Word16 -> IO Int
fin41enc _ 0 _ _ = pure 0
fin41enc !table 1 !src !dst = do
  x <- peek src
  let code = table `unsafeIndex` fromIntegral x
      upper16 = asBE $ fromIntegral $ asBE code `shiftR` 16
  poke dst upper16
  pure 2
fin41enc _ _ _ _ = fail "Something Terrible Happened in Base41 Encoding"

-- | Build an encoder using a base41 lookup table generated by 'mkBase41Table'.

make41encoder :: (FlatArray a, FlatArray b) => Base41EncodeTable -> a -> b
make41encoder table bs = mapChunks 2 3 (enc41 table) (fin41enc table) bs

-- | Encode something with base41
encode41 :: (FlatArray a, FlatArray b) => a -> b
encode41 = make41encoder (make41encodeTable base41alphas)

-- -----------------------------------------------------------------------------

-- | Decoding

type Base41DecodeTable = Vector Word8

make41decodeTable :: ByteString -> Base41DecodeTable
make41decodeTable alphabet = generate 256 $ \x ->
  maybe 255 fromIntegral $ elemIndex (fromIntegral x) alphabet

type Combiner = Word16 -> Word16 -> Word16 -> IO Word16

combine :: Combiner
combine a b c = pure $ a * 41 * 41 + b * 41 + c

combineCheck :: Combiner
combineCheck a b c = 
  if a .|. b .|. c == 255
     then fail "Invalid Base41 Symbol"
     else combine a b c

dec41 :: Base41DecodeTable -> Combiner -> Ptr Word8 -> Ptr Word16 -> IO ()
dec41 !table combiner !src !dst = do
  a <- lu <$> peek @Word8 src
  b <- lu <$> peek @Word8 (plusPtr src 1)
  c <- lu <$> peek @Word8 (plusPtr src 2)
  combiner a b c >>= poke dst . asBE
 where
   lu :: Word8 -> Word16
   lu x = fromIntegral $ table `unsafeIndex` fromIntegral x

fin41dec :: Base41DecodeTable -> Combiner -> Int -> Ptr Word8 -> Ptr Word8 -> IO Int
fin41dec _ _ 0 _ _ = pure 0
fin41dec _ _ 1 _ _ = pure 0
fin41dec !table combiner 2 !src !dst = do
  a <- lu <$> peek @Word8 src
  b <- lu <$> peek @Word8 (plusPtr src 1)
  x <- combiner a b 40
  poke dst $ fromIntegral $ x
  pure 1
 where
   lu :: Word8 -> Word16
   lu x = fromIntegral $ table `unsafeIndex` fromIntegral x
fin41dec _ _ _ _ _ = fail "Something Terrible Happened in Base41 Decoding"

-- | Make a strict decoder from a table.
make41decoderStrict :: (FlatArray a, FlatArray b) => Base41DecodeTable -> a -> Either String b
make41decoderStrict table = attempt $ mapChunks 3 2 (dec41 table combineCheck) (fin41dec table combineCheck)

-- | Make a lenient decoder from a table.
make41decoderLenient :: (FlatArray a, FlatArray b) => Base41DecodeTable -> a -> b
make41decoderLenient table = mapChunks 3 2 (dec41 table combine) (fin41dec table combine)

-- Our decode table.
base41DecodeTable :: Base41DecodeTable
base41DecodeTable = make41decodeTable base41alphas

-- | Decode something encoded with base41, catching invalid symbols.
decode41Strict :: ByteString -> Either String ByteString
decode41Strict = make41decoderStrict base41DecodeTable

-- | Decode something encoded with base41, saturating invalid symbols.
decode41Lenient :: ByteString -> ByteString
decode41Lenient = make41decoderLenient base41DecodeTable

